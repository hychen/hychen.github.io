#+TITLE: 資訊工程
#+OPTIONS: H:2
#+HTML_LINK_HOME: ../index.html
#+HTML_LINK_UP: ../index.html
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="/blog/css/readtheorg.css" />

* Assignment V.S. Binding

所謂的 Functional Language 的變數不可改其實是不精確的。實際上它只是將變數分的更嚴謹，可修改，與不可修改。
先來說說什麼是 Binding. Binding 指的是將一個符號綁定在一個值，綁定後就不可修改，這個符號稱之為變數。以自然語言來理解的話，其實就是代名詞。

#+BEGIN_QUOTE
favonia: 一個變數沒有指到一個值。一個變數可以被一個值取代，但不會儲存什麼內容在裡面。
#+END_QUOTE

所以說下面這個例子， 必須理解為3.14的另一個稱呼叫做 PI, 而不是 PI 這個容器的值是 3.14。而  1 + PI 這個式子的另一個稱呼是 result, 而不是 1 + PI 運算後，將值放到 result 這個容器裡。 不管是PI，還是 result 都只是個代稱，而不是容器。

#+BEGIN_SRC javascript
PI = 3.14
result = 1.0 + PI
#+END_SRC

接下來搭配 SML 來解釋什麼是 Assignment。
下面這段 code 是說 PI 是 3.14的binding, result 是 1 + PI 的binding。
程式執行時(runtime) 會把 PI 這個變數代換成3.14。

#+BEGIN_SRC javascript
val PI = 3.14
val result = 1.0 + PI
#+END_SRC 

那如果需要可修改的變數怎麼辦，SML 可以讓變數綁在值的的指標上, ref 3.14
指的是 3.14 這個值得指標指標。而因為指標指定的值是可以變的，所以現在
PI 可以當成是可以修改的。 PI := 4 只是讓 PI 的值(也就是指標) 從 3.14
指到 4，並不會產生新的binding。

#+BEGIN_SRC javascript
val PI = ref 3.14 # binding
val result = 1.0 + PI # binding
val PI := 4 # assign
#+END_SRC

因此，在所有的 imperative language 裡，不管是Python, Ruby, C, Java, 
變數其實都是被綁在指標上，這樣變數指到的值才能被修改。

所以說，變數只是個值的代稱，如果值是指標，那麼就可以修改指標要指到哪個
值，反之則不行。
但不管怎麼說，變數都不應該被當成是一個容器。

* Study Of Coordination Language And Models
** Patterns
- [[http://workflowpatterns.com][Workflow Patterns]]
- [[http://communicationtheory.org/patterns-of-communication/][Communication Patters]]
- Dsitrubuted Computing Software Architecture Pattern
  - [[http://www.cs.wustl.edu/~schmidt/POSA/POSA4/][Pattern-Oriented Software Architecture: A Pattern Language for Distributed Computing]]
- Enterprise Intergration Patterns
  - [[http://www.enterpriseintegrationpatterns.com/toc.html][Messaging Patterns]]
** Coordination Language And Models
*** Papers
**** Coordination models and languages, GA Papadopoulos, F Arbab, 1999
***** The concept of coordination is by no means limited to Computer Science.
Malone and Crowston characterise coordination as an emerging research area with an interdisciplinary focus,
playing a key issue in many diverse disciplines such as economics and operational  research,  organisation theory  and  biology.
***** What is Coordination Model
- the glue that binds separate activities into an ensemble.
- The need of Multilingual and Heterogeneous Systems
*****  Coordination works well  on distributed/parallel programming.
Programming a distributed or parallel system can be seen as the combination of two distinct activities: the actual
computing part comprising a number of processes involved in manipulating data and a coordination part responsible for
the communication and cooperation between the processes. Thus, coordination can be used to distinguish the computational
concerns of some distributed or parallel application from the communication ones, allowing the separate development but also
the eventual amalgamation of the these two major development phases.
***** Data-Driven
- The main characteristic of the data-driven coordination models and languages is the fact that the state of the computation at any moment
  in time is defined in terms of both the values of the data being received or sent and the actual configuration of the coordinated components.
- A data-driven coordination language typically offers some coordination primitives (coupled with a coordination metaphor) which are mixed within
  the purely computational part of  the  code.  These  primitives  do  encapsulate  in  a  useful  way  the  communication  and configurational
  aspects of some computation, but must be used in conjunction with the purely computational manipulation of data associated with some process.
  This means that processes cannot easily be distinguished as either coordination or computational processes.
****** Data-Driven Model - Shared Data Space
- Almost all coordination models belonging to this category have evolved around the notion of a *Shared Dataspace*.
- A *Shared  Dataspace* is a common, content-addressable  data structure. All processes involved in some computation can communicate among themselves only indirectly via this medium.
  this metaphor achieves decoupling of processes in both space and time.
****** Data-Driven Model - Message-passing

****** Data-Driven Model - Compositional Programming
- A compositional programming system is one in which properties of program
  components are preserved when those components are composed in parallel
  with other program components.
  Thus, it is possible to define in a compositional way recurring patterns
  of parallel computation, whether configuration ones (such as mapping techniques)
  or communication ones (such as streamers  and  mergers),  as  building  blocks
  and  combine  them  together  to  form  bigger programs.
- 2 approachs
  - *concurrent logic programming*
  - *functional programming*
***** Control-Driven
- the coordinated framework evolves by means of observing state changes in processes
  and, possibly, broadcast of events. Contrary to the case of the data-driven family
  where coordinators directly handle and examine data values, here processes
  (whether coordination or computational ones) are treated as black boxes; data handled
  within a  process is of no concern to the environment of the process.
- Processes communicate with their environment by means of clearly defined interfaces,
  usually referred to as input or output ports. Producer-consumer relationships are formed
  by means of setting up stream or channel connections between output ports of producers
  and input ports of consumers. By nature, these connections are point-to-point, although
  limited  broadcasting functionality  is  usually  allowed  by  forming  1-n
  relationships  between  a  producer  and  n consumers and vice versa.
- Most of the coordination languages to be described in this section realise in one way or
  another the above *CSP*- or *Occam-like* formalism.
- *static reconfiguration* v.s. *dynamic reconfiguration*
- [[http://projects.cwi.nl/manifold/][MANIFOLD]]
***** Comparision Between Data-Driven and Control-Driven
- In the case of the data-driven category, the coordination component is usually a set of primitives with predefined functionality which is used in connection with
  some “host” computational language, in the control-driven category the coordination component is usually a fully-fledged language.
- The data-driven category tends to be used mostly for parallelising computational problems. The control-driven category tends to be used primarily for modelling systems.
- the data- vs. control-driven separation is by no means a clear cut one.
***** Major Dimensions Of Coordination Model
- the entities being coordinated
- the mechanism of coordination
- the coordination medium or architecture
- the semantics, rules of protocols of coordination employed
- whether a model supports a different (from the computational component) coordination language or involves the use of “add-on” primitives
- whether a model supports and encourages the use of many computational languages
- what is the most relevant application domain for each  model
- what is the implementation status of the proposed framework.
***** Concerned Issues
- flat unstructured communication medium v.s. hierarchical levels of their communication medium
- port-to-port connections via streams with static/dymaic reconfiguration support.
- channnled-based v.s. medium-based

** Web Services Compositions
*** Papers
**** van der Aalst, W.M.P, Dumas, M. ; ter Hofstede, A.H.M..  (2003). Web Service Composition Languages: Old Wine in New Bottles?. IEEE.
**** Luca Cardelli and Rowan Davies. . (1997). Service Combinators for Web Computing. IEEE.
** Data Flow
*** Books
**** Morrison, J. P. (1994). Flow-based programming. Van Nostrand Reinhold.
**** Van-Roy, P., & Haridi, S. (2004). Concepts, techniques, and models of computer programming. MIT press.
**** Matt Carkci. (2014). Dataflow and Reactive Programming Systems. Leanpub.
*** Papers
****  Kelly, J. L., Lochbaum, C., & Vyssotsky, V. A. (1961). A block diagram compiler. Bell System Technical Journal, 40(3), 669-676.
**** Sutherland, W. R. (1966). ON-LINE GRAPHICAL SPECIFICATION OF COMPUTER PROCEDURES (No. TR-405). LINCOLN LAB MASS INST OF TECH LEXINGTON.
**** Rodrigues, J. E., & Rodriguez Bezos, J. E. (1969). A Graph Model for Parallel Computations.
**** Dennis, J. B. (1972). On the design and specification of a common base language (No. MAC-TR-101). MASSACHUSETTS INST OF TECH CAMBRIDGE PROJECT MAC.
**** Dennis, J. B. (1974, January). First version of a data flow procedure language. In Programming Symposium (pp. 362-376). Springer Berlin Heidelberg.
**** Gilles, K. A. H. N. (1974). The semantics of a simple language for parallel programming. In In Information Processing’74: Proceedings of the IFIP Congress (Vol. 74, pp. 471-475).
**** Karp, R. M., & Miller, R. E. (1966). Properties of a model for parallel computations: Determinacy, termination, queueing. SIAM Journal on Applied Mathematics, 14(6), 1390-1411.
**** Karp, R. M., & Miller, R. E. (1966). Properties of a model for parallel computations: Determinacy, termination, queueing. SIAM Journal on Applied Mathematics, 14(6), 1390-1411.
**** Nikhil, R. S. (1989, April). Can dataflow subsume von Neumann computing?. In ACM SIGARCH Computer Architecture News (Vol. 17, No. 3, pp. 262-272). ACM.
**** Karp, R. M., & Miller, R. E. (1966). Properties of a model for parallel computations: Determinacy, termination, queueing. SIAM Journal on Applied Mathematics, 14(6), 1390-1411.
**** Berry, G. (1989). Real time programming: Special purpose or general purpose languages.
**** Lee, E. (1991). Consistency in dataflow graphs. Parallel and Distributed Systems, IEEE Transactions on, 2(2), 223-235.
**** Buck, J., & Lee, E. A. (1992, May). The token flow model. In Data Flow Workshop.
**** Hils, D. D. (1992). Visual languages and computing survey: Data flow visual programming languages. Journal of Visual Languages & Computing, 3(1), 69-101.
**** Hurson, A. R., Hurson, A. R., Lee, B., & Lee, B. (1993). Issues in dataflow computing. Adv. in Comput, 37(285-333), 38-39.
**** Buck, J. T., & Lee, E. A. (1993, April). Scheduling dynamic dataflow graphs with bounded memory using the token flow model. In Acoustics, Speech, and Signal Processing, 1993. ICASSP-93., 1993 IEEE International Conference on (Vol. 1, pp. 429-432). IEEE.
**** Bhattacharyya, S. S., & Lee, E. A. (1994). Looped schedules for dataflow descriptions of multirate signal processing algorithms. Formal Methods in System Design, 5(3), 183-205.
**** Bhattacharyya, S. S., Buck, J. T., Ha, S., & Lee, E. A. (1995). Generating compact code from dataflow specifications of multirate signal processing algorithms. Circuits and Systems I: Fundamental Theory and Applications, IEEE Transactions on, 42(3), 138-150.
**** Parks, T. M. (1995). Bounded scheduling of process networks (Doctoral dissertation, University of California). Chicago
**** Parks, T. M., Pino, J. L., & Lee, E. A. (1995, October). A comparison of synchronous and cycle-static dataflow. In Signals, Systems and Computers, 1995. 1995 Conference Record of the Twenty-Ninth Asilomar Conference on (Vol. 1, pp. 204-210). IEEE.
**** Lee, E. A., & Parks, T. M. (1995). Dataflow process networks. Proceedings of the IEEE, 83(5), 773-801.
**** Verdoscia, L. O. R. E. N. Z. O. (1996). ALFA fine grain dataflow machine. International Programming, ma orgun and ea ashcroft edition.
**** Lee, E. A. (1997). A denotational semantics for dataflow with firing. Electronics Research Laboratory, College of Engineering, University of California.
**** Robic, B., Silc, J., & Ungerer, T. (2000). Beyond dataflow. Journal of Computing and Information Technology, 8(2), 89-102.
**** Lee, B. (2000). Specification and design of reactive systems (Doctoral dissertation, UNIVERSITY of CALIFORNIA).
**** Liu, J., & Lee, E. A. (2002). A component-based approach to modeling and simulating mixed-signal and hybrid systems. ACM Transactions on Modeling and Computer Simulation (TOMACS), 12(4), 343-368.
**** Johnston, W. M., Hanna, J. R., & Millar, R. J. (2004). Advances in dataflow programming languages. ACM Computing Surveys (CSUR), 36(1), 1-34.
**** Petersen, A., Putnam, A., Mercaldi, M., Schwerin, A., Eggers, S., Swanson, S., & Oskin, M. (2006, September). Reducing control overhead in dataflow architectures. In 「Proceedings of the 15th international conference on Parallel architectures and compilation techniques (pp. 182-191). ACM.
**** Lee, E. A. (2009). Computing needs time. Communications of the ACM, 52(5), 70-79.
**** Arandi, S., & Evripidou, P. (2010, July). Programming multi-core architectures using data-flow techniques. In Embedded Computer Systems (SAMOS), 2010 International Conference on (pp. 152-161). IEEE.
**** Lee, E. A., & Varaiya, P. (2011). Structure and interpretation of signals and systems, Second Edition, LeeVaraiya.org.
**** Amsden, E. (2011). A survey of functional reactive programming. Unpublished.
**** Sousa, T. B. (2012). Dataflow Programming Concept, Languages and Applications. In Doctoral Symposium on Informatics Engineering.
**** Odersky, M., & Maier, I. (2012). Deprecating the Observer Pattern with Scala. React (No. EPFL-REPORT-176887).
**** Mishra, V., & Oney, K. Predictive Block Dataflow Model for Parallel Computation.
**** Chakilam, S. R. A. K. C., & O’Neil, T. W. STATIC SCHEDULING FOR CYCLO STATIC DATA FLOW GRAPHS.

* Flow-Based Programming 2ND Edition, J. Paul Morrison 
:PROPERTIES:
:Authoer: J. Paul Morrison
:ISBN: 1451542321
:PublishedDate: 2011
:END:
** Terms
- Configurable modularity :: a term coined by Raoul de Campo of IBM Research and later expanded on by Nate Edwards of the same organization, denoting the ability to reuse independent components by changing their interconnections, but not their internals.[1] In Edwards' view this characterizes all successful reuse systems, and indeed all systems which can be described as "engineered".
** Mentioned People

| Name              | Page | Purpose                                                            |   |
|-------------------+------+--------------------------------------------------------------------+---|
| Wayne Stevens     |    5 | 強調FBP會成為典範轉移的重要因素                                    |   |
| David Gelernter   |    7 | 指出FBP是 Coordination Language的一種例子                          |   |
| Nicholas Carriero |    7 |                                                                    |   |
| Raoul de Campo    |    7 | 介紹Raoul 研究的 "configurable modularity                          |   |
| Nate Edwards      |    7 | 指出Nate Edwards 的 configurable modularity 研究篇硬體所以沒被重視 |   |
| Jackson 1975      |   24 | 指出 Design 跟 Impleentartion 在FBP的概念                          |   |

*** [[https://en.wikipedia.org/wiki/Wayne_Stevens][Wayne Stevens]] 

- A software engineer, chief architect of application development methodology 
  for IBM's consulting group.
- Important works are 
  - [[https://en.wikipedia.org/wiki/Structured_analysis][Structured Design]] 

*** [[https://en.wikipedia.org/wiki/David_Gelernter][David Gelernter]]
- Parallel Computation
*** Nicholas Carriero

** Notes
*** Chaoter 0: Prologue
作者自介自己的成長背景，大學在 King's college 就讀人類學系，並且強調將人類行為轉換成符號邏輯是件很困難的事情
在他的IBM生涯中，不斷碰觸到IBM電腦的瓶頸，這使得他開始專注在一個基本問題 - 為什麼在電腦上開發程式這麼困難，當要讓電腦做一些人類覺得很簡單的事情時。
**** Reusable Code
作者寫過 Compiler (BABEL), 也寫過 Interpreter (BLIS), 而在那個年代已經有 reusable subroutine library，只是幾乎都是一次性函數, 
像是*binary function*, 他曾試圖撰寫通用的大量更新的*function*, 但卻失敗了(只支援少數的資料集合), 這些經驗讓他開始思考是否有另一種方式
可以產生可再用的程式碼。
**** Rapid Prototyping 
作者相信不管做任何事，只要有懷疑的地方，就先做出一個 prototyping, 並認為好的 prototyping 是可以一直成長，直到成為完整的系統。
並提到[David的書:1]也有說到數種結合互動式開發與Milestone的放式。

[1]: Exploiting Chaos: Cashing in on the realities of Software Development, 1993, Dave Olson
**** Focus Of This Book
The approach mentioned hre is for bussiness applications, not mathematical applications.
**** Thinking things visual term
由於他媽媽使母親的關係，使他在成長過程中常使用圖像式思考，在這本書提到的很重要的一點是使用圖像是符號來開發程式，有個好處是能利用到人類的圖像思考能力。
間或提到 [GPSS:2]對他的影響，使他在介紹資料處理時是從單一 Record，而非電腦邏輯。(作者沒有電腦科學訓練)

[2]: General Purpose Simulation System
**** Application Design is a creative activity  
**** Fun
- The word "amateur" comes from the idea of loving. One should be proud to be called an computing amateur.
- If an activity isn't fun, humans probaly shouldn't be doing it. 
- The guys who turn out the most code are the ones who are having fun! - P.R Ewing.
- Play is not something we have to put away when we reach the state of adulthood
*** Chpater 1: Introduction
敘述FBP實作的應用程式很容易被修改以達成目標，並強調這是個存在四十年以上且被驗證的技術。
讓開發者專注在data transformation的方式，而不是procedural code，讓開發者專注在快速開發，產生跟容易維護的系統。
同時，FBP也很適合分散式運算。
作者同時指出，FBP需要數天到數週的學習時間。因為FBP背後隱含的思考模型與傳統程式相當不同。
要把sequencial program改成支援multiplethread很困難，而 Von Neumann Computer Model 是讓程式開發非常困難的原因之一
**** FBP != Data Flow 
- flow-based programming shares some basic concept with dataflow 
  architectures in computer design, but they are still not the same.
- 作者認為要使用FBP是因為dataflow archtecture 不包含control flow的部分，而FBP包含，
  因此要使用另一個名稱以方便區隔。
- 其他大多數 data flow programming 專注在數學運算，但FBP不僅僅是
- 作者曾有過的模擬器經驗，讓他意識到若讓物件在這些運算中流動，會有更好的生產力。
**** Entity flow throw the network
- each entity reoresents an object with attributes.
- the term *entity*, *object* is too often used in many aspects, to more be 
  cliafied, the author defines a new term *Information Packets*.
**** 打預防針
- 避免讀者快速下結論說FBP就只是..., 而放棄了閱讀
*** Chapter 2: High-Level Languages, 4GLs and Source Code Reuse
*** Chapter 3: Basic Concepts
*** Chapter 4: Reuse of components
*** Chapter 5: Parametrization of Reusable Components
*** Chapter 6: Composite Components
*** Chapter 7: Building Components & Some More Simple Applications
*** Chapter 8: Substreams and Control IPs
- 大約有1/4 商業程式是在做 Update，用非FBP做會非常困難。
*** Chapter 9: Some more components and Simple Applications
*** Chapter 10: Data Descriptions and Descriptors
*** Chapter 11: Tree Structure
*** Chapter 12: Scheduling Rules
*** Chapter 13: Loop-Type Networks
*** Chapter 14: Implementation, Network Splitting and Client-Server
*** Chapter 15: Deadlocks: Their Causes and Prevention
*** Chapter 16: Problem-Oriented Mini Language
*** Chapter 17: A Bussiness-Oriented Very High Level Language
*** Chapter 18: Synchronization and Checkpoints
*** Chapter 19: General Framwork for Interactive Applications
*** Chapter 20: Performance Considerations
*** Chapter 21: Defining Networks
*** Chapter 22: Related Compiler Theory Concepts
*** Chapter 23: Streams and Recursive Function Definitions
*** Chapter 24: Comparison between FBP and Object-Oriented Porgramming
*** Chapter 25: Related Concepts and Forerunners
*** Chapter 26: The FBP Explosion
*** Chapter 27: Ending and Beginnings
*** Appendix: FBP Implementations and Diagramming Tool
