#+TITLE: Web Development
#+OPTIONS: H:2
#+HTML_LINK_UP: ../index.html

* Full Text Searching
** Mongodb Text Search
*** Text Index
- only allow one text index per collection.
- $language parameter.
*** Control Search Results with Weights
- https://docs.mongodb.com/manual/core/index-compound/
``` 
db.blog.createIndex(
   {
     content: "text",
     keywords: "text",
     about: "text"
   },
   {
     weights: {
       content: 10,
       keywords: 5
     },
     name: "TextIndex"
   }
 )
```
*** Storage Requirements and Performance Costs
text indexes can be large. They contain one index entry for each unique post-stemmed word in each indexed field for each document inserted.
- Building a text index is very similar to building a large multi-key index and will take longer than building a simple ordered (scalar) index on the same data.
- When building a large text index on an existing collection, ensure that you have a sufficiently high limit on open file descriptors. See the recommended settings.
- text indexes will impact insertion throughput because MongoDB must add an index entry for each unique post-stemmed word in each indexed field of each new source document.
- Additionally, text indexes do not store phrases or information about the proximity of words in the documents. As a result, phrase queries will run much more effectively when the entire collection fits in RAM.
*** Text Search.  
- $text, $match
https://docs.mongodb.com/manual/tutorial/text-search-in-aggregation/
*** References
- http://willowtreeapps.com/blog/text-searching-with-mongodb/
** Solr
** Elasticsearch
* Web Performance
- Edge Cache :: The cache on edge servers, controlled by CDN or proxy server.
- Browser Cache :: The cache on browser, controlled by browser.
* HTTP1.1 Cache Control
*** Expiration
**** Request
***** no-store
***** max-age
***** max-stale
***** min-fresh
***** no-transform
***** only-if-cached
**** Response 
***** public
***** private
***** no-cache
***** no-store
***** no-transform
***** must-revalidate
***** proxy-revalidate
***** max-age
***** s-maxage
*** Validation
**** [[https://en.wikipedia.org/wiki/HTTP_ETag][ETag]]
***** ETag Value
1. is unique.
2. typically looks like as the following:
#+BEGIN_VERSE
"123456789"    – A strong ETag validator
W/"123456789"  – A weak ETag validator
#+END_VERSE
3. Common methods of ETag generation include using a collision-resistant hash function 
   of the resource's content, a hash of the last modification timestamp, or even just a revision number.
***** Pros.
1. Don't rely on client's clock.
***** Cons.
1. ETag requests a client make at least a request, so it might not that useful 
if the lantecy betwen a client to your server is high, which leads the pages loading still 
took too long.
**** Last-Modified
1. does same thing as ETag does but it is timebased checking.
2. unit is seconds.
3. GMT.
*** Conclution  
1. For cache expiration, use *max-age* to reduce requests, use *private* when handling sesetive data.
3. use *ETag* or *Last-Modified* to valid content.
