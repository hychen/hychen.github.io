#+TITLE: JavaScript
#+OPTIONS: tex:t 
#+HTML_LINK_UP: ./index.html

* 浮點數運算精度問題
#+CAPTION: from xkcd
[[https://imgs.xkcd.com/comics/e_to_the_pi_minus_pi.png]]

JavaScript 的 Number 是 64 bit 的雙精度浮點數([[https://zh.wikipedia.org/wiki/IEEE_754][IEEE754]])，這邊出現的問題在其他語言都會發生。

** 加法的誤差
$0.1+0.2 \neq 0.3$
#+BEGIN_SRC js :cmd "node" :results output :exports both
console.log(0.1 + 0.2)
#+END_SRC

#+RESULTS:
: 0.30000000000000004
** 減法的誤差
$0.12 - 0.1 \neq 0.02$
#+BEGIN_SRC js :cmd "node" :results output :exports both
console.log(0.12 - 0.1)
#+END_SRC

#+RESULTS:
: 0.01999999999999999
** 乘法的誤差
$3.21 \times 3 \neq 9.63$
#+BEGIN_SRC js :cmd "node" :results output :exports both
console.log(3.21 * 3)
#+END_SRC

#+RESULTS:
: 9.629999999999999
** 除法的誤差
$0.3 \div 0.1 \neq 3$
#+BEGIN_SRC js :cmd "node" :results output :exports both
console.log(0.3 / 0.1)
#+END_SRC

#+RESULTS:
: 2.9999999999999996

** 三角函數的誤差
$\sin(\pi) \neq 0$
#+BEGIN_SRC js :cmd "node" :results output :exports both
console.log(Math.sin(Math.PI))
#+END_SRC

#+RESULTS:
: 1.2246467991473532e-16
** 分配律有時不成立

$(0.1 + 0.2) \times 5 \neq 0.1 \times 5 + 0.2 \times 5$

#+BEGIN_SRC js :cmd "node" :results output :exports both
var a = (0.1 + 0.2) * 5;
var b = 0.1 * 5 + 0.2 * 5;
console.log('(0.1 + 0.2) * 5 = ' + a);
console.log('0.1 * 5 + 0.2 * 5 = ' + b);
#+END_SRC

#+RESULTS:
: (0.1 + 0.2) * 5 = 1.5000000000000002
: 0.1 * 5 + 0.2 * 5 = 1.5
** 四捨五入誤差的影響
多跑了一次回圈，因為預期最後一次結果是3，結果得到1.9999999999999998。

#+BEGIN_SRC js :cmd "node" :results output :exports both
  var start = 1;
  var end = 2;
  var x, h;

  h = (end-start)/3
  x = start;
  console.log("x=",x);
  while(x<end) {
    x=x+h;
    console.log("x=",x);
  }
#+END_SRC

#+RESULTS:
: x= 1
: x= 1.3333333333333333
: x= 1.6666666666666665
: x= 1.9999999999999998
: x= 2.333333333333333

** 失去精確位數
太相近的數值相減的結果完全不可信

$3.141592653589793$ - $3.141592653585682 \neq 0.000000000004111$
#+BEGIN_SRC js :cmd "node" :results output :exports both
var x = 3.141592653589793;
var y = 3.141592653585682;
var z = x - y;
console.log("x - y = ", z);
#+END_SRC

#+RESULTS:
: x - y =  4.11093381558203e-12
** 如何判斷兩個浮點數相等
由於有 round error, 所以兩個浮點數可能只有非常微小的差別，通常我們會將之視為兩數是相同的。

#+CAPTION: The following is js port of http://floating-point-gui.de/errors/comparison/.
#+BEGIN_SRC js :results output :exports both
  function sameNumber(a, b, epsilon) {
    var epsilon = epsilon || 0.00001;
    var absA = Math.abs(a);
    var absB = Math.abs(b);
    var diff = Math.abs(a - b);

    if (a === b) {
      return true;
    }
    else if (a === 0 || b === 0 || diff < Number.MIN_VALUE) {
      // a or b is zero or both are extremely close to it
      // relative error is less meaningful here
      return diff < (epsilon * Number.MIN_VALUE);
    }
    else {
      // use relative error
      return diff / Math.min((absA + absB), Number.MAX_VALUE) < epsilon;
    }
  }

console.log('sameNumber(3.141592653589793, 3.141592653585682) is', sameNumber(3.141592653589793, 3.141592653585682));
#+END_SRC

#+RESULTS:
: sameFloat(3.141592653589793, 3.141592653585682) is true

** 結論 
- 乘法與除法是安全的。
- 加法與減法是容易出錯的，需要多加留意。
  - 盡量把減法運算用其他演算方式消掉。
  - 盡量不要讓太相近的數值相減。
- 如果非常在乎計算後的結果，使用特別的資料格式，像是[[https://jsperf.com/bignumber-js-vs-big-js-vs-decimal-js/8][BigDecimal]]。
** 參考連結
- [[http://blog.dcview.com/article.php?a=VmhQNVY%2BCzo%3D][使用浮點數最最基本的觀念]],洗鏡光, 2008
- [[http://blog.chewxy.com/2014/02/24/what-every-javascript-developer-should-know-about-floating-point-numbers/][What Every JavaScript Developer Should Know About Floating Point Numbers]], chewxy, 2014
- [[http://floating-point-gui.de/][What Every Programmer Should Know About Floating-Point Arithmetic]]
